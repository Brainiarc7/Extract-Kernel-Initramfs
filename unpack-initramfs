#!/bin/bash
# This is an update version of the script found at 
# http://forum.xda-developers.com/wiki/index.php?title=Extract_initramfs_from_zImage
#
# The problem with that script is that the gzip magic number occasionally occur 
# naturally, meaning that some non-compressed files get uncompressed.


DEBUG=
TEMP_DIR=/tmp
KERNEL_FILE=kernel
INITRAMFS_FILE=initramfs.cpio
INITRAMFS_DIR=initramfs_root

# DO NOT MODIFY BELOW THIS LINE
[ -z $1 ] && exit 1 || zImage=$1
[ ! -e $1 ] && exit 1


function pre_clean()
{
    [ -z $DEBUG ] || echo "-D- Function: pre_clean()"
    [ -e $INITRAMFS_FILE ] && ( [ -z $DEBUG ] || echo "-D- Deleting $INITRAMFS_FILE"; rm -f $INITRAMFS_FILE )
    [ -e $INITRAMFS_DIR ] && ( [ -z $DEBUG ] || echo "-D- Deleting $INITRAMFS_DIR"; rm -rf $INITRAMFS_DIR )
    [ -z $DEBUG ] || echo
}

function ungzip_kernel()
{
    #========================================================
    # find start of gziped kernel object in the zImage file:
    #========================================================
    [ -z $DEBUG ] || echo "-D- Function: ungzip_kernel()"

    pos=`grep -P -a -b -m 1 --only-matching '\x1F\x8B\x08' $zImage | cut -f 1 -d :`
    echo "-I- Extracting gzip'd kernel image from \"$zImage\" (start = $pos)"

    if [ ! -z $pos ]; then
        dd if=$zImage of=${TEMP_DIR}/kernel.gz bs=1 skip=$pos 2>/dev/null >/dev/null
        gunzip -qf $TEMP_DIR/kernel.gz
        inputfile=$KERNEL_FILE
    else
        echo "-E- Compressed kernel image not found"; exit 1
    fi
    [ -z $DEBUG ] || echo
}

function search_cpio()
{
    #========================================================
    # Determine cpio compression type:
    #========================================================
    [ -z $DEBUG ] || echo "-D- Function: search_cpio()"

    for x in gzip bzip2 lzma none; do
        case $x in
            bzip2)
                compress='\x{42}\x{5A}\x{68}\x{39}\x{31}\x{41}\x{59}\x{26}\x{53}\x{59}'
                cmd='bunzip2 -q'
                ;;

            gzip)
                compress='\x1F\x8B\x08'
                cmd='gunzip -q'
                ;;

            lzma)
                compress='\x{5D}\x{00}\x..\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}'
                cmd='unlzma -q'
                ;;

            none)
                compress='070701'
                cmd=
                ;;
        esac

        #========================================================================
        # Search for compressed cpio archive
        #========================================================================
        pos=`grep -P -a -b -m 1 --only-matching "${compress}" /$TEMP_DIR/${inputfile} | cut -f 1 -d :`

        if [ ! -z $pos ]; then
            if [ ! $pos -gt ${cpio_compressed_start:-0} ] || [ ${cpio_compressed_start:-0} -eq 0 ]; then
                cpio_compressed_start=$pos
                uncompress_cmd=$cmd
                compression_type=$x

                [ -z $DEBUG ] || echo '-D- Checking compression signature | pos=`grep -P -a -b -m 1 --only-matching '"${compress}"' '$TEMP_DIR/${inputfile}' | cut -f 1 -d :`'
                [ compress = "bzip2" ] && cpio_compressed_start=$((cpio_compressed_start - 4))
            fi
        fi
    done 

    echo "-I- CPIO compression type detected = $compression_type | pos = $cpio_compressed_start"
    [ -z $DEBUG ] || echo
}

function uncompress_cpio()
{
    [ -z $DEBUG ] || echo "-D- Function: uncompress_cpio()"

    if [ ! $compression_type = "no" ]; then
        echo "-I- Extracting CPIO image from kernel image compressed using $compression_type (start = $cpio_compressed_start)"

        [ -z $DEBUG ] || echo "-D- dd if=$TEMP_DIR/${inputfile} bs=1 skip=$cpio_compressed_start | $uncompress_cmd > $TEMP_DIR/cpio.img"
        dd if=$TEMP_DIR/${inputfile} bs=1 skip=$cpio_compressed_start | $uncompress_cmd > $TEMP_DIR/$INITRAMFS_FILE
        inputfile=$INITRAMFS_FILE
    fi
    [ -z $DEBUG ] || echo
}

function extract_cpio()
{
    #==========================================================================
    # find start and end of the "cpio" initramfs image inside the kernel object:
    # ASCII cpio header starts with '070701'
    # The end of the cpio archive is marked with an empty file named TRAILER!!!
    #==========================================================================
    [ -z $DEBUG ] || echo "-D- Function: extract_cpio()"

    start=`grep -a -b -m 1 --only-matching '070701' $TEMP_DIR/${inputfile} | head -1 | cut -f 1 -d :`
    end=`grep -a -b -m 1 --only-matching 'TRAILER!!!' $TEMP_DIR/${inputfile} | head -1 | cut -f 1 -d :`


    if [ ! -z $start ] || [ ! -z $end ]; then
        #11 bytes = length of TRAILER!!! zero terminated string, fixes premature end of file warning in CPIO
        end=$((end + 14))
        [ -z $DEBUG ] || echo "-D- Kernel start = $start"
        [ -z $DEBUG ] || echo "-D- Kernel end = $end"
        count=$((end - start))

        if (($count < 0)); then
            echo "-E- Couldn't match start/end of the initramfs image."
            exit 1
        fi

        echo "-I- Extracting initramfs image from $inputfile (start = $start, end = $end)"
        dd if=$TEMP_DIR/$inputfile of=$INITRAMFS_FILE bs=1 skip=$start count=$count 2>/dev/null >/dev/null
    else
        
        echo "-E- No CPIO image found in $inputfile"
    fi
    [ -z $DEBUG ] || echo
}

function expand_cpio_archive()
{
    [ -z $DEBUG ] || echo "-D- Function: expand_cpio_archive()"
    echo "-I- Expanding CPIO archive"

    if [ -e $INITRAMFS_FILE ]; then
        mkdir $INITRAMFS_DIR
        cd $INITRAMFS_DIR
        cpio --quiet -i --make-directories --preserve-modification-time --no-absolute-filenames -F ../$INITRAMFS_FILE 2>/dev/null
    fi
    [ -z $DEBUG ] || echo
}

function clean_up()
{
    rm -f $TEMP_DIR/$KERNEL_FILE
    rm -f $TEMP_DIR/${inputfile}
}





reset
pre_clean
ungzip_kernel
search_cpio
uncompress_cpio
extract_cpio
expand_cpio_archive
clean_up
